# CPrimer
C++笔记

## 类
### 聚合类
        1、所有成员都是public的
        2、没有定义任何构造函数
        3、没有类内初始值
        4、没有基类，也没有virtual函数
### IO 条件状态
        badbit                  用来指出流已经崩溃
        failbit                 用来指出一个IO操作失败
        eofbit                  用来指出流达到了文件结束
        goodbit                 用来指出流未处于错误状态
        cin.eof() cin.fail() cin.bad() cin.good()
        cin.clear()             将流中的所有状态复位
        cin.clear(flags)        将流中的指定状态复位
        cin.setstate(flags)     将指定的状态置位
        cin.rdstate()           返回当前流的状态
        enum _Ios_Iostate
        { 
            _S_goodbit 		= 0,
            _S_badbit 		= 1L << 0,
            _S_eofbit 		= 1L << 1,
            _S_failbit		= 1L << 2,
            _S_ios_iostate_end = 1L << 16,
            _S_ios_iostate_max = __INT_MAX__,
            _S_ios_iostate_min = ~__INT_MAX__
        };
### 缓冲区刷新条件
        1、程序正常结束
        2、缓冲区满
        3、使用endl、flush、ends(输出一个空字符，然后刷新缓冲区);
        4、使用标志unitbuf(开启立即刷新)、nounitbuf(关闭立即刷新)
        5、关联流，主动关联的流执行之前，会刷新被关联的流，例如：cin关联到cout，在执行cin从终端接收输入之前，会先刷新cout的缓冲区（场景：输出提示语句，提示用户输入，然后获取用户的输入，如果没有关联的话，会导致等待用户输入，然而提示语句没有输出，应该保证等待用户输入之前就先输出用户提示）
        s.tie()没有参数，返回s关联的流。例如cin.tie()，返回的是cout
        s.tie(&stream)，关联流，s关联新的流stream，并返回旧的流。(每个流同时最多关联一个流，但是可以同时被很多其他流关联)
### IO继承关系
        1、istream和ostream继承ios
        2、iostream继承于istream和ostream
        3、fstream和sstream继承于iostream
        4、ifstream和istringstream继承于istream
        5、ofstream和ostringstream继承于ostream
## STL
### 顺序容器类型
        1、vector       可变大小数组，支持快速随机访问。在尾部之外的位置插入删除元素很慢
        2、array        固定大小数组，支持快速随机访问，不能添加或删除元素
        3、string       与vector相似的容器，但专门用于保存字符，随机访问快，在尾部插入删除快
        4、deque        双端队列，支持快速随机访问，在头尾部插入删除快
        5、list         双向链表，只支持双向顺序访问，在任意位置插入删除操作速度都很快
        6、forward_list 单向链表，只支持单向顺序访问，在任意位置插入删除操作速度都很快
### 容器适配器
        1、stack                底层一般是deque封装，但可以自己指定底层容器
        2、queue                底层一般是deque封装，但可以自己指定底层容器
        3、priority_queue       底层一般是vector封装，但可以自己指定底层容器
### 泛型算法
        大多数算法在头文件algorithm，也有在numeric中
#### 只读算法
        1、find()
        2、accumulate() 在numeric中
        3、equal()
#### 写容器元素算法
        1、fill()/fill_n()
        2、copy()
        3、replace()/replace_copy()
#### 重排容器元素的算法
        1、sort
        2、unique       返回的是不重复元素的下一个位置的迭代器
        3、transform
#### 定制操作
        谓词：一个可调用的表达式、其返回结果是一个能用作条件的值
        一元谓词：接受一个参数
        二元谓词：接受两个参数
        stable_sort()   稳定排序算法，在字符串排序过程中能保证字典顺序
        lambda表达式    不能有默认参数，对于值拷贝捕获的变量，在lambda表达式内部是不允许修改的，如果要修改则需要再（）后面加入mutable
        for_each()
        bind()          可以修改函数的参数个数以及更改参数顺序
        ref()           返回一个对象，包含给定的引用，此对象是可以拷贝的。cref()
### 迭代器
        每个容器自带的迭代器才是真正的迭代器，而下面的四种迭代器，具有迭代器的性质的同时也具有适配器的性质，因此应该是迭代器适配器
#### 插入迭代器
        back_inserter
        front_inserter
        inserter
#### 流迭代器
        istream_iterator
        ostream_iterator
#### 反向迭代器
#### 移动迭代器
### 仿函数
        仿函数就是类中重载了()运算符
## 关联容器
### map
#### map
#### multimap
#### unordered_map
#### unordered_multimap
### set
#### set
#### multiset
#### unordered_set
#### unordered_multiset
## 三/五法则
        1、如果一个类需要析构函数，那么我们几乎可以肯定他也需要拷贝构造函数和一个拷贝赋值运算符
        2、如果一个类需要拷贝构造函数，那么几乎可以肯定也需要一个拷贝赋值运算符，反之亦然
## default
        1、使用default就是告诉编译器生成默认的合成版本，就不需要自己再去写定义
        2、如果是在类内部的构造函数使用default默认是inline，如果不想要inline那么在内中声明的时候不使用default，在内外定义的时候使用default
        3、内中的类默认是inline的，如果不想是inline那么就在类中声明，类外定义
        4、explict是用来禁用隐式转换，只能加在定义处，不能加在声明处
        5、有些场景不需要甚至要阻止拷贝构造和赋值，那么就在类中把这两个地方的default换成delete表明要删除这两种操作（delete必须出现在第一次声明的时候，且delete可以指定任何成员函数，但是default只能指定能默认合成定义的函数；例如构造和赋值运算符等等）(析构函数不能delete)
        6、如果一个类有数据成员不能默认构造、拷贝】赋值或销毁，则对应的成员函数将被定义为删除的
## noexcept
        1、void myFunction() noexcept;
        在函数声明或函数类型中使用 noexcept 关键字，表示该函数不会抛出异常，如果在实际执行中引发了异常，程序会调用 std::terminate 终止程序的执行。
        2、int result = noexcept(someExpression);
        在表达式中使用 noexcept 关键字，用于检查某个表达式是否可能引发异常。如果表达式不会引发异常，noexcept 运算符的结果为 true，否则为 false。
## 移动构造函数和移动赋值运算符
        只有当一个类没有定义任何自己版本的拷贝构造控制成员，且类中每个非static成员都能移动时，编译器才会为他合成移动构造函数或移动赋值运算符
## 第十四章 冲在运算与类型转换
### 输入和输出运算法
        1、自定义的IO重载运算符必须是非成员函数
## 第十五章 面向对象程序设计
### 动态绑定
        1、当我们使用基类的引用或者指针调用虚函数时就会发生动态绑定（运行时绑定）
        2、基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际的操作
        3、如果希望派生类重新定义继承过来的函数，那么就要在基类的这个函数前面加上virtual
        4、关键字virtual只能出现在类内，不能出现在类外
        5、成员函数如果没有被定义成virtual则其解析过程发生在编译时而非发生在运行时
        6、只有表达式是指针或者引用的时候，它的静态类型和动态类型才有可能不一样，其他情况下，两者是一样的
### 继承
        1、如果我们想将一个类作为基类，则该类必须已经定义了而非仅仅只是声明
        2、如果不想这个类被别人继承，则只需添加关键字final
### 多态
        1、使用dynamic_cast请求一个类型转换，该转换的安全检查将在运行时执行
        2、如果已知基类向派生类转换是安全的，则可以使用static_cast来强制覆盖掉编译器的检查工作
        3、虚函数可以拥有默认实参，如果虚函数的某次调用使用了默认实参，则该实参的值由本次调用的静态类型决定
        4、可以使用指定域::来指定调用哪个虚函数，而不是运行时绑定
### 抽象基类
        1、在虚函数后面加上=0该虚函数就变成了纯虚函数，=0只能出现在类内部的虚函数声明处
        2、我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部
        3、派生类的成员和友元只能访问派生类对象中的基类部分的受保护对象，对于普通基类对象中的成员不具有特殊的访问权限
        4、派生类只为那些他能够访问的名字提供using声明
        5、如果派生类的成员与基类中的某个成员同名，则基类中的成员就会被隐藏，即使是参数列表不一样，也会被隐藏
        6、有了显示的拷贝构造函数之后，如果没有显示的移动构造函数，如果能合成（派生类能合成移动构造函数的前提是直接基类能首先合成），就会默认合成移动构造函数，反之不成立（有了移动构造函数就不会默认合成拷贝构造函数）
        7、构造函数与析构函数调用了某个虚函数，则应该执行与构造函数或虚构函数所属类型相对应的虚函数版本
        8、类不会继承默认、拷贝、移动构造函数，但是显示的会继承
## 第十六章 模板与泛型编程
        1、如果一个成员函数没有被使用，则它不会被实例化
        2、当我们希望通知编译器一个名字表示类型时，必须使用关键字typename而不能使用class。例如：类外定义的成员函数名前面的类作用域不是使用具体类名而是使用模板，则需要再在前面加上typename
        3、成员模板不能是虚函数